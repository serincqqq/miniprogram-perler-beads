# 像素拼豆辅助小程序 (Perler Beads Helper)

## 项目介绍

本项目是一个微信小程序，旨在为拼豆（Perler Beads / Hama Beads / Artkal Beads）爱好者提供一站式解决方案。它能够将用户上传的任意图片，智能转换为像素风格的拼豆设计图纸，并提供从校准、颜色替换到最终图纸导出的全套创作工具，极大地简化了拼豆的创作流程。

**原图示例：**
<img width="380" alt="Original Pixel Art" src="https://github.com/user-attachments/assets/12abca9f-fd45-463d-898e-0a3fca491ad9" />

**转换后带色号的网格图：**
<img width="380" alt="Generated Grid with Codes" src="https://github.com/user-attachments/assets/d887a72a-9b80-4f2d-b4b0-0176e5b81345" />

## 功能亮点

1.  **图片上传与智能分析**：
    *   支持从用户相册或相机选择图片。
    *   程序自动对图片进行像素化处理和颜色量化，生成基础的拼豆数据。

2.  **交互式单元格校准 (`Calibration`)**：
    *   提供创新的校准弹窗，允许用户通过拖动四条轴线，在图片上直观地"框选"出单个拼豆单元格的精确范围。
    *   解决了传统像素分割因错位导致的图纸不准问题，确保了图纸与实物的精准对应。

3.  **动态网格微调**：
    *   在校准后，依然提供对网格**单元格宽高**和**整体偏移**的精细调整功能，允许用户修正校准误差，达到完美的网格对齐效果。

4.  **多色板支持与颜色匹配**：
    *   内置多种常用色板（如221色、168色、144色等），用户可根据自己持有的拼豆颜色进行选择。
    *   采用**RGB空间欧氏距离算法**，将图片每个单元格的平均色，精准匹配到所选色板中的最接近颜色。

5.  **预览与二次创作 (`Preview & Edit`)**：
    *   提供一个带色号的网格图预览页面，用户可以缩放并滑动查看图纸的每一个细节。
    *   **颜色替换**：用户可以点击色板中的任意颜色，输入新的色号进行替换。
    *   **颜色删除**：支持将图纸中的某个颜色直接"删除"（变更为透明），并从色板中移除。
    *   **智能色板更新**：当颜色A被替换为已存在的颜色B时，色板会自动合并，只显示一个颜色B的色块。

6.  **高清图纸导出**：
    *   一键将最终的设计图纸（包含所有颜色修改）导出为带网格和色号标注的高清图片。
    *   导出时，单元格内的色号文字颜色会根据背景色的明暗自动切换为黑色或白色，保证最佳可读性。
    *   支持将导出图片直接保存到用户手机相册，并提供完善的相册授权管理。

## 技术实现

*   **前端框架**：微信小程序原生开发 (`WXML`, `WXSS`)
*   **核心语言**：`TypeScript`
*   **核心绘图**：`Canvas 2D` API 及 `OffscreenCanvas` (离屏渲染)
    *   使用 `OffscreenCanvas` 在 Worker 线程或后台执行密集的图像处理和绘制任务，避免UI阻塞。
    *   通过 `ctx.getImageData` 进行像素级的数据采样和分析。
*   **颜色匹配算法**：
    *   实现 HEX 与 RGB 颜色空间的相互转换。
    *   通过计算两种颜色的**欧氏距离 (Euclidean Distance)** `√((r2-r1)² + (g2-g1)² + (b2-b1)²) ` 来寻找最匹配的色板颜色。
*   **数据持久化与传递**：
    *   使用 `wx.setStorageSync` / `wx.getStorageSync` 在页面间传递复杂的图像数据对象。
    *   通过 `Set` 和 `Map` 数据结构高效处理颜色去重与替换逻辑。
*   **异步流程管理**：广泛使用 `Promise` 和 `async/await` 语法，处理文件IO、Canvas绘制等异步操作，使代码逻辑更清晰。
*   **组件化与工程化**：
    *   封装了自定义导航栏 (`navigation-bar`) 等可复用组件。

## 核心逻辑拆解

1.  **图像处理管线 (`_processImageToGrid`)**:
    *   **采样**：在主页 `Canvas` 上加载用户图片，并根据用户设定的网格参数（宽高、偏移），划分出逻辑上的单元格。
    *   **计算平均色**：遍历每个逻辑单元格所覆盖的像素区域，使用 `getImageData` 提取像素信息，计算出该区域的平均R, G, B值。
    *   **颜色匹配**：将平均色与所选色板中的所有颜色计算欧氏距离，找到距离最小的颜色，将其色号作为该单元格的 `finalColorCode`。
    *   **数据生成**：最终生成一个包含所有核心信息的 `processedData` 对象，其中包括一个关键的二维数组 `imageData` (例如 `[['A1', 'A2'], ['G1', 'G2']]`)，它精确描述了图纸的每一个格子。

2.  **页面间数据流**:
    *   **Index -> Preview**: 主页调用 `_processImageToGrid` 生成数据，并使用 `_drawGridToCanvas` (一个可复用的绘图函数) 生成一张**带色号的预览图**。将这张图的路径 `tempFilePath` 和核心数据 `imageData` 等打包存入 `storage`，然后跳转到预览页。
    *   **Preview**: 预览页从 `storage` 中加载数据，显示预览图，并允许用户修改 `imageData` (通过替换和删除颜色)。
    *   **导出**: 预览页的导出功能，会基于**当前被修改过的 `imageData`**，重新在离屏 `Canvas` 上绘制最终图纸并保存。同时，将修改后的 `imageData` 写回 `storage`，以便返回主页后数据能保持同步。
    *   **Preview -> Index**: 主页的 `onShow` 生命周期函数会监听 `storage` 的变化，当用户从预览页返回时，可以加载到最新的 `imageData`，为下一次操作做准备。

3.  **实时预览的颜色替换 (已废弃方案的思考)**
    *   项目曾探索过在预览页使用 `Canvas` 进行实时绘制的方案。该方案通过在 `setData` 的回调中触发 `Canvas` 的重绘函数，实现了对颜色替换的即时响应。虽然最终因产品需求调整为显示静态图，但该方案的实现体现了对小程序渲染机制和性能优化的深入理解。
