# 像素拼豆辅助小程序 (Perler Beads Helper Mini Program)

## 项目介绍

本项目是一个微信小程序，旨在帮助拼豆（Perler Beads / Hama Beads / Artkal Beads 等）爱好者将普通图片转换为像素风格的拼豆图纸，并提供一系列辅助工具，简化拼豆创作过程。用户可以上传图片，通过校准工具精确选取图片的有效区域和单元格大小，选择不同的色板进行颜色匹配，并最终导出一个带有颜色代码和网格的拼豆图纸。

**原图（像素图）：**
<img width="380" alt="7531746622642_ pic" src="https://github.com/user-attachments/assets/12abca9f-fd45-463d-898e-0a3fca491ad9" />

**转换后的带色号的网格图：**
<img width="380" alt="7531746622642_ pic" src="https://github.com/user-attachments/assets/d887a72a-9b80-4f2d-b4b0-0176e5b81345" />

## 功能点

1.  **图片上传与预览**：
    *   支持从用户相册选择图片或使用相机拍照。
    *   实时在画布上预览选中的图片。

2.  **图像校准**：
    *   提供交互式校准弹窗。
    *   用户可以通过拖动四条轴线（上、下、左、右）来精确定义图片中单个拼豆单元格所对应的区域。
    *   解决直接按像素点分割可能产生的错位问题，确保图纸与实际拼豆的对应关系。

3.  **动态网格调整**：
    *   **单元格数量确认**：用户可以输入期望的横向拼豆数量，程序根据图片比例自动计算纵向数量。
    *   **单元格尺寸微调**：提供“增大/减小”按钮，以及“宽度/高度”加减按钮，让用户微调网格单元格的实际像素宽高。
    *   **网格偏移调整**：提供“上/下/左/右”按钮，让用户微调整个网格的显示偏移。
    *   **实时显示当前格子宽高**：以两位小数精度显示当前网格单元格的像素宽度和高度。
    *   **重置网格**：一键恢复到根据“单元格数量确认”计算的初始网格状态。

4.  **色板选择与颜色匹配**：
    *   内置多种色板选项（如：全色系291色、168色、144色、96色、72色）。
    *   用户可以根据自己拥有的拼豆颜色范围选择合适的色板。
    *   导出图纸时，程序会自动将图片中每个网格的平均颜色匹配到所选色板中最接近的颜色。

5.  **带色码的图纸导出**：
    *   一键导出带有网格和颜色代码的拼豆图纸。
    *   颜色代码直接显示在每个拼豆单元格中（例如 "A3", "H7"）。
    *   网格线和颜色代码文本颜色会根据背景色自动调整，保证可读性。
    *   支持保存导出图片到用户手机相册。
    *   区域合并：智能识别并合并相似颜色区域，减少色彩跳变
    *   背景透明：自动识别背景颜色并设置为透明，便于套用到其他场景

6.  **界面交互优化**：
    *   加载状态提示（如“生成中…”）。
    *   操作成功或失败的 Toast 提示。
    *   Canvas 尺寸根据容器动态调整，适应不同屏幕。
    *   禁用图像平滑，保持像素画的清晰度。

## 技术实现

*   **前端框架**：微信小程序原生开发。
*   **核心绘图**：使用微信小程序 `Canvas 2D` API 进行图像绘制、网格生成、颜色代码标注等。
*   **状态管理**：通过 Page 的 `data` 对象管理视图状态，并通过 `setData` 更新。
*   **用户交互**：通过 `bindtap`、`bindchange` 等事件处理用户操作。
*   **图像处理（基础）**：
    *   获取图片信息 (`wx.getImageInfo`)。
    *   在 Canvas 上绘制图片 (`ctx.drawImage`)。
    *   获取 Canvas 区域的像素数据 (`ctx.getImageData`)。
    *   计算区域平均色。
*   **颜色匹配**：
    *   HEX 颜色与 RGB 颜色互转。
    *   计算 RGB 颜色之间的欧氏距离 (Euclidean distance) 来寻找最接近色。
*   **数据存储**：色板数据 (`beadPaletteData.json`, `palette.js`) 作为本地资源打包在小程序内。
*   **异步处理**：使用 `Promise` 和 `async/await` 处理异步操作（如图片加载、文件保存）。
*   **响应式布局**：部分使用 Flex 布局，Canvas 尺寸动态计算。

## 核心算法与逻辑

1.  **图像校准逻辑**：
    *   用户在校准弹窗中通过触摸拖动四条轴线（`leftAxis`, `rightAxis`, `topAxis`, `bottomAxis`），这四条线定义了一个矩形区域。
    *   在“应用校准”时，获取这个矩形区域在校准图片容器中的像素宽高。
    *   根据校准图片容器的实际尺寸和原图的尺寸比例，以及校准UI中可能存在的缩放因子（例如，如果校准图被放大2倍显示），计算出这个选定区域对应到原图上单个拼豆单元格的实际像素尺寸 (`actualCellWidth`, `actualCellHeight`)。
    *   这些计算出的单元格尺寸将作为主画布网格绘制的基准。

2.  **动态网格绘制 (`drawAdjustableGrid`)**：
    *   基于当前的 `gridCellWidth`, `gridCellHeight`, `gridOffsetX`, `gridOffsetY`。
    *   通过取模运算 (`%`) 和循环，从画布的有效起始点开始，按照单元格宽高绘制横向和纵向的网格线。
    *   线条绘制时考虑设备像素比 (`dpr`)，确保物理1px的清晰线条。

3.  **颜色平均与匹配 (`exportImg` 内部)**：
    *   **遍历逻辑单元格**：根据主画布的 `gridCellWidth`, `gridCellHeight` 和偏移量，确定每个逻辑单元格的覆盖范围。
    *   **采样物理像素**：将逻辑单元格的范围乘以 `dpr` 转换为主画布物理像素范围。
    *   **获取像素数据**：使用 `this.ctx.getImageData()` 从主画布（物理像素层面）提取对应区域的像素数据。
    *   **计算平均色**：累加采样区域内所有像素的 R, G, B 值，然后除以像素数量，得到该单元格的平均 RGB 颜色。
    *   **查找最接近色**：
        *   将用户选定的色板中的所有颜色（通常为 HEX）预先转换为 RGB 对象，并存储（`paletteRgbMap`）。
        *   将上一步计算得到的单元格平均 RGB 色，与 `paletteRgbMap` 中的每一个颜色计算欧氏距离。
        *   距离最小的那个色板颜色即为该单元格的最佳匹配色，记录其颜色代码。

4.  **导出带色码的高清图 (`exportImg`)**：
    *   **创建离屏 Canvas**：创建一个新的、比主画布尺寸更大（由 `exportScaleFactor` 控制）的离屏 Canvas。
    *   **绘制原图**：将用户图片绘制到这个放大的离屏 Canvas 上。
    *   **绘制网格和色码**：
        *   遍历之前计算好的每个单元格的数据（位置、尺寸、匹配到的颜色代码、平均色）。
        *   所有绘制操作（单元格边框 `strokeRect`, 文字 `fillText`）的坐标和尺寸都要乘以 `exportScaleFactor`。
        *   网格线宽和字体大小也相应放大。
        *   文字颜色根据单元格的平均亮度动态选择黑色或白色以确保可读性。
    *   **保存图片**：使用 `wx.canvasToTempFilePath` 将离屏 Canvas 内容转换为图片文件，然后用 `wx.saveImageToPhotosAlbum` 保存。

5.  **浮点数精度处理**：
    *   在进行如 `+ 0.2` 或 `- 0.2` 这样的浮点数运算后，立即使用 `parseFloat(value.toFixed(2))` 来修正潜在的精度误差，确保存储在 `data` 中的 `gridCellWidth` 和 `gridCellHeight` 是精确到两位小数的数字。
    *   用于界面显示的 `formattedGridCellWidth` 和 `formattedGridCellHeight` 始终由这些修正后的数字通过 `toFixed(2)` 生成。
